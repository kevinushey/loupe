#!/usr/bin/env bash

set +H

read -r -d '' USAGE <<- EOF
Usage: $(basename "$0") pid

Use a debugger to attach to an R process, and print the R call stack.

Options:

  -d    Specify the path to the debugger to be used.
  -e    Run an R expression in the requested process.
  -f    Run an R script in the requested process.
  -o    The file where R frames should be saved.

EOF

if [ "$#" = "0" ] || [ "$1" = "--help" ]; then
	printf "%s\n\n" "${USAGE}"
	exit 0
fi

realpath () {
	echo "$(cd "$(dirname "$1")"; pwd -P)/$(basename "$1")"
}

while [ "$#" != "0" ]; do

	case "$1" in

	-d)
		LOUPE_DEBUGGER="$2"
		shift
	;;

	-e)
		LOUPE_R_EXPRESSION="$2"
		shift
	;;

	-f)
		LOUPE_R_FILE="$2"
		shift
	;;

	-o)
		R_FRAMES_PATH=$(realpath "$2")
		shift
	;;

	*)
		PID="$1"
		shift
	;;

	esac

	shift

done

# figure out debugger to be used
if [ -z "${LOUPE_DEBUGGER}" ]; then
	if [ "$(uname)" = "Darwin" ]; then
		LOUPE_DEBUGGER=lldb
	else
		LOUPE_DEBUGGER=gdb
	fi
fi

if ! command -v "${LOUPE_DEBUGGER}" &> /dev/null; then
	echo "error: requested debugger '${LOUPE_DEBUGGER}' does not exist"
	exit 1
fi

# if we've been supplied the name of a process,
# rather than a process id, then try to resolve it
if ! [ "${PID}" -eq "${PID}" ] 2> /dev/null; then

	_PID="$(pgrep -nx "${PID}")"

	if [ -z "${_PID}" ]; then
		echo "error: could not resolve PID for process '${PID}'"
		exit 1
	fi

	PID="${_PID}"

fi

# TODO: we could consider hooking lldb up to an input / output
# socket and keeping lldb and its connection alive for longer

# path for R outputs
R_TRACEBACK_PATH="$(mktemp).log"

if [ -z "${R_FRAMES_PATH}" ]; then
	R_FRAMES_PATH="$(mktemp).rds"
fi

# write R script
R_SCRIPT_PATH="$(mktemp).R"
cat > "${R_SCRIPT_PATH}" <<- EOF

# print rlang traceback if available
if ("rlang" %in% loadedNamespaces()) {
	frames <- sys.frames()
	if (length(frames) > 3L) {
		bottom <- frames[[length(frames) - 3L]]
		traceback <- format(rlang::trace_back(0, bottom))
		writeLines(traceback, con = "${R_TRACEBACK_PATH}")
	}
}

# dump frames to file
status <- sys.status()
saveRDS(sys.status(), file = "${R_FRAMES_PATH}", version = 2L)

EOF

run-lldb () {

	# write script
	SCRIPT_PATH=$(mktemp)
	cat > "${SCRIPT_PATH}" <<- EOF

	# disable interrupts
	call int \$interrupts = R_interrupts_suspended
	call R_interrupts_suspended = (Rboolean) 1

	# disable debugger
	call int \$debug = RDEBUG(R_GlobalEnv)
	call SET_RDEBUG(R_GlobalEnv, 0)

	# disable garbage collector
	call int \$gc = R_GCEnabled
	call R_GCEnabled = 0

	# source script
	call Rf_eval(Rf_lang3(Rf_install("sys.source"), Rf_mkString("${R_SCRIPT_PATH}"), Rf_lang1(Rf_install("new.env"))), R_GlobalEnv)

	# restore debugger
	call SET_RDEBUG(R_GlobalEnv, \$debug)

	# restore interrupts
	call R_interrupts_suspended = (Rboolean) \$interrupts

	# restore garbage collection
	call R_GCEnabled = \$gc
	EOF

	printf "%s" "Attaching debugger ... "
	"${LOUPE_DEBUGGER}" --batch --attach-pid "${PID}" --source "${SCRIPT_PATH}" > /dev/null
	STATUS="$?"
	if [ "${STATUS}" != "0" ]; then
		echo "ERROR: ${LOUPE_DEBUGGER} had status code ${STATUS}"
		exit 1
	fi

	printf "%s\n" "Done!"

}

run-gdb () {

	# write script
	SCRIPT_PATH=$(mktemp)
	cat > "${SCRIPT_PATH}" <<- EOF
	
	# disable interrupts
	call \$interrupts = R_interrupts_suspended
	call R_interrupts_suspended = (Rboolean) 1

	# disable debugger
	call \$debug = RDEBUG(R_GlobalEnv)
	call SET_RDEBUG(R_GlobalEnv, 0)

	# disable garbage collector
	call \$gc = R_GCEnabled
	call R_GCEnabled = 0

	# source script
	call Rf_eval(Rf_lang3(Rf_install("sys.source"), Rf_mkString("${R_SCRIPT_PATH}"), Rf_lang1(Rf_install("new.env"))), R_GlobalEnv)

	# restore debugger
	call SET_RDEBUG(R_GlobalEnv, \$debug)

	# restore interrupts
	call R_interrupts_suspended = (Rboolean) \$interrupts

	# restore garbage collection
	call R_GCEnabled = \$gc
	EOF

	printf "%s" "Attaching debugger ... "

	LOUPE_DEBUGGER_OUTPUT=$(mktemp)
	"${LOUPE_DEBUGGER}" -batch -p "${PID}" -x "${SCRIPT_PATH}" &> "${LOUPE_DEBUGGER_OUTPUT}"
	STATUS="$?"
	if [ "${STATUS}" != "0" ]; then
		cat "${LOUPE_DEBUGGER_OUTPUT}"
		echo "ERROR: ${LOUPE_DEBUGGER} had status code ${STATUS}"
		exit 1
	fi

	rm -f -- "${LOUPE_DEBUGGER_OUTPUT}"
	printf "%s\n" "Done!"

}

case "${LOUPE_DEBUGGER}" in
*gdb)  run-gdb  ;;
*lldb) run-lldb ;;
esac

if [ -f "${R_TRACEBACK_PATH}" ]; then
	echo ""
	echo -e "\033[1m\033[34m==>\033[0m \033[1mTraceback (most recent calls last)\033[0m"
	cat "${R_TRACEBACK_PATH}"
	echo ""
fi

if [ -f "${R_FRAMES_PATH}" ]; then
	echo "R frames dumped to '${R_FRAMES_PATH}'."
fi

stty echo
